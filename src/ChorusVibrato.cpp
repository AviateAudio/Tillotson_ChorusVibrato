/*
 * Company: Tillotson
 * Effect Name: Hammond Chorus Vibrato
 * Description: A circuit simulation of the Hammond Scanner Vibrato.
 *
 * This file was auto-generated by Aviate Audio Effect Creator for the Multiverse.
 *
 * Copyright (c) 2020, Mark Tillotson
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#include "Aviate/EfxPrint.h"
#include "ChorusVibrato.h"

using namespace Aviate;

namespace Tillotson_ChorusVibrato {

using byte = uint8_t;

#define OVERSAMPLING_RATE 2

ChorusVibrato::ChorusVibrato()
: AudioStream(NUM_INPUTS, m_inputQueueArray),
  V{0.0f}, I{0.0f}
{

}

ChorusVibrato::~ChorusVibrato()
{
    // perform any necessary clean up here, though destructors are not
    // called on the hardware, only in the simulator.
}

// This has been pregenerated for 48.0 KHz.
// TODO: generate at init time for arbitrary sampling rate.
PROGMEM constexpr float CROSSFADE_ARRAY[440] = {0.000000f, 0.000040f, 0.000173f, 0.000392f, 0.000701f, 0.001099f, 0.001584f, 0.002163f, 0.002824f, 0.003584f, 0.004430f, 0.005355f, 0.006383f, 0.007488f, 0.008675f, 0.009957f, 0.011324f, 0.012783f, 0.014332f, 0.015969f, 0.017704f, 0.019528f, 0.021436f, 0.023431f, 0.025519f, 0.027681f, 0.029928f, 0.032273f, 0.034683f, 0.037111f, 0.039544f, 0.041973f, 0.044402f, 0.046845f, 0.049283f, 0.051717f, 0.054162f, 0.056597f, 0.059011f, 0.061419f, 0.063836f, 0.066264f, 0.068685f, 0.071113f, 0.073553f, 0.075990f, 0.078427f, 0.080878f, 0.083328f, 0.085767f, 0.088171f, 0.090582f, 0.092986f, 0.095402f, 0.097830f, 0.100255f, 0.102685f, 0.105132f, 0.107577f, 0.110023f, 0.112482f, 0.114944f, 0.117347f, 0.119738f, 0.122142f, 0.124558f, 0.126971f, 0.129394f, 0.131834f, 0.134273f, 0.136717f, 0.139178f, 0.141640f, 0.144100f, 0.146515f, 0.148908f, 0.151297f, 0.153700f, 0.156118f, 0.158537f, 0.160965f, 0.163413f, 0.165862f, 0.168317f, 0.170788f, 0.173264f, 0.175699f, 0.178071f, 0.180459f, 0.182860f, 0.185262f, 0.187678f, 0.190113f, 0.192552f, 0.194999f, 0.197467f, 0.199940f, 0.202413f, 0.204875f, 0.207248f, 0.209619f, 0.212008f, 0.214413f, 0.216822f, 0.219245f, 0.221691f, 0.224142f, 0.226602f, 0.229082f, 0.231570f, 0.234067f, 0.236419f, 0.238788f, 0.241173f, 0.243560f, 0.245966f, 0.248394f, 0.250829f, 0.253276f, 0.255749f, 0.258228f, 0.260713f, 0.263217f, 0.265604f, 0.267956f, 0.270327f, 0.272717f, 0.275112f, 0.277527f, 0.279968f, 0.282417f, 0.284879f, 0.287367f, 0.289863f, 0.292363f, 0.294783f, 0.297133f, 0.299498f, 0.301869f, 0.304260f, 0.306678f, 0.309105f, 0.311550f, 0.314023f, 0.316507f, 0.319001f, 0.321517f, 0.323977f, 0.326307f, 0.328659f, 0.331030f, 0.333411f, 0.335814f, 0.338246f, 0.340690f, 0.343151f, 0.345642f, 0.348145f, 0.350656f, 0.353164f, 0.355493f, 0.357836f, 0.360188f, 0.362563f, 0.364968f, 0.367384f, 0.369823f, 0.372294f, 0.374779f, 0.377278f, 0.379804f, 0.382341f, 0.384675f, 0.387005f, 0.389357f, 0.391718f, 0.394107f, 0.396527f, 0.398963f, 0.401420f, 0.403911f, 0.406417f, 0.408937f, 0.411480f, 0.413870f, 0.416191f, 0.418521f, 0.420877f, 0.423265f, 0.425667f, 0.428097f, 0.430562f, 0.433045f, 0.435546f, 0.438079f, 0.440626f, 0.443060f, 0.445368f, 0.447697f, 0.450038f, 0.452409f, 0.454814f, 0.457238f, 0.459688f, 0.462176f, 0.464682f, 0.467207f, 0.469760f, 0.472264f, 0.474561f, 0.476868f, 0.479204f, 0.481572f, 0.483957f, 0.486375f, 0.488830f, 0.491308f, 0.493808f, 0.496345f, 0.498899f, 0.501463f, 0.503748f, 0.506052f, 0.508371f, 0.510721f, 0.513108f, 0.515517f, 0.517957f, 0.520438f, 0.522941f, 0.525468f, 0.528027f, 0.530605f, 0.532950f, 0.535232f, 0.537544f, 0.539890f, 0.542256f, 0.544658f, 0.547101f, 0.549569f, 0.552066f, 0.554602f, 0.557161f, 0.559734f, 0.562145f, 0.564425f, 0.566718f, 0.569047f, 0.571413f, 0.573803f, 0.576229f, 0.578700f, 0.581197f, 0.583722f, 0.586285f, 0.588871f, 0.591356f, 0.593613f, 0.595901f, 0.598222f, 0.600566f, 0.602948f, 0.605376f, 0.607831f, 0.610321f, 0.612854f, 0.615414f, 0.617993f, 0.620561f, 0.622815f, 0.625083f, 0.627386f, 0.629728f, 0.632098f, 0.634507f, 0.636964f, 0.639451f, 0.641972f, 0.644534f, 0.647125f, 0.649738f, 0.652013f, 0.654274f, 0.656569f, 0.658888f, 0.661249f, 0.663657f, 0.666097f, 0.668575f, 0.671103f, 0.673660f, 0.676242f, 0.678860f, 0.681224f, 0.683465f, 0.685741f, 0.688058f, 0.690403f, 0.692792f, 0.695233f, 0.697706f, 0.700219f, 0.702777f, 0.705369f, 0.707989f, 0.710431f, 0.712666f, 0.714933f, 0.717224f, 0.719561f, 0.721947f, 0.724368f, 0.726832f, 0.729349f, 0.731900f, 0.734482f, 0.737106f, 0.739652f, 0.741865f, 0.744114f, 0.746403f, 0.748722f, 0.751088f, 0.753508f, 0.755965f, 0.758464f, 0.761018f, 0.763604f, 0.766219f, 0.768869f, 0.771077f, 0.773314f, 0.775578f, 0.777887f, 0.780248f, 0.782646f, 0.785093f, 0.787596f, 0.790138f, 0.792716f, 0.795341f, 0.797993f, 0.800286f, 0.802506f, 0.804765f, 0.807055f, 0.809395f, 0.811791f, 0.814228f, 0.816713f, 0.819255f, 0.821835f, 0.824450f, 0.827105f, 0.829508f, 0.831715f, 0.833948f, 0.836228f, 0.838562f, 0.840935f, 0.843360f, 0.845846f, 0.848375f, 0.850946f, 0.853569f, 0.856224f, 0.858726f, 0.860917f, 0.863145f, 0.865404f, 0.867716f, 0.870086f, 0.872499f, 0.874965f, 0.877493f, 0.880063f, 0.882674f, 0.885331f, 0.887959f, 0.890136f, 0.892338f, 0.894587f, 0.896891f, 0.899235f, 0.901637f, 0.904102f, 0.906613f, 0.909173f, 0.911790f, 0.914445f, 0.917125f, 0.919349f, 0.921545f, 0.923772f, 0.926053f, 0.928393f, 0.930780f, 0.933224f, 0.935734f, 0.938290f, 0.940893f, 0.943549f, 0.946240f, 0.948578f, 0.950748f, 0.952966f, 0.955237f, 0.957551f, 0.959926f, 0.962365f, 0.964860f, 0.967393f, 0.969911f, 0.972379f, 0.974796f, 0.976899f, 0.978613f, 0.980281f, 0.981914f, 0.983511f, 0.985070f, 0.986603f, 0.988107f, 0.989578f, 0.991020f, 0.992417f, 0.993775f, 0.994948f, 0.995584f, 0.996181f, 0.996738f, 0.997249f, 0.997736f, 0.998190f, 0.998618f, 0.999017f, 0.999383f, 0.999714f, 1.000000f};


void ChorusVibrato::init()
{
    scanner_ph = 0 ;
    scanner_seg = 0 ;
    tap = 0 ;
    ntap = 1 ;

    SAMPS_PER_SEG = int( std::round(AUDIO_SAMPLE_RATE_EXACT / (6.83f*16))); // 48000 / (6.83*16) = 439;
    crossfade = (float*)malloc(440*sizeof(float));
    if (!crossfade) { return; }

    memcpy(crossfade, CROSSFADE_ARRAY, 440 * sizeof(float));

    m_led = !m_bypass;
    sendValueReport(LED_e, m_led);

    m_initComplete = true;
}

void ChorusVibrato::update(void)
{
    if (!m_initComplete) { init(); }
    audio_block_t *inputAudioBlock = receiveWritable(); // get the next block of input samples
    inputAudioBlock = m_basicInputCheck(inputAudioBlock, 0); // check for disable mode, bypass, or invalid inputs. Transmit to channel 0 in bypass
    if (!inputAudioBlock) { return; } // no further processing for this update() call

    // You must call m_updateInputPeak() before processing the audio
    m_updateInputPeak(inputAudioBlock);

    // DO AUDIO EFFECT PROCESSING
    for (unsigned i=0; i<AUDIO_SAMPLES_PER_BLOCK; i++) {
        float s = inputAudioBlock->data[i] ;

        simulate_lineunit (butterworth (2*s)) ;  // interpolate to 88200 SPS, pass to circuit simulator
        simulate_lineunit (butterworth (0)) ;

        // simulate scanner unit with smoothed triangular cross-fade
        float interpolated = crossfade [scanner_ph]                 * out[ntap]
                        + crossfade [SAMPS_PER_SEG - scanner_ph] * out[tap] ;
        float mixed = m_mix*interpolated + (1.0f - m_mix)*s;

        inputAudioBlock->data[i] = (int16_t)(mixed * m_volume);

        scanner_ph += 1 ;  // update the scanner segment state
        if (scanner_ph >= SAMPS_PER_SEG)
        {
            scanner_seg += 1 ;
            scanner_seg &= 0xF ;
            scanner_ph = 0 ;
            set_taps () ;
        }
    }

    m_updateOutputPeak(inputAudioBlock); // you must call m_upateOutputPeak() at the end of update() before transmit
    transmit(inputAudioBlock);
    release(inputAudioBlock);
}

void ChorusVibrato::bypass(bool byp)
{
    m_led = !byp;
    m_bypass = byp;
    sendValueReport(LED_e, m_led);
}

void ChorusVibrato::volume(float value)
{
    float volDbValue = -40.0f + (value * 50.0f);  // remap the normalized value to represent -40dB to +10dB
    volumeDb(volDbValue);  // AudioEffectFloat has built-in volume function in dB

    // Demonstrate the efxLogger.printf() function to print over the USB serial port
    // Note: efxLogger.printf() statements will have no effect in RELEASE builds
    efxLogger.printf("volume change: normalized value: %f  dB value: %f\n", value, volDbValue);
}

void ChorusVibrato::mode(float value)
{
    // perform any necessary conversion to user variables, validation, etc.
    m_mode = value;
    vibrato = static_cast<bool>(m_mode);
    efxLogger.printf("ChorusVibrato::vibrato: %d\n", vibrato);
}

void ChorusVibrato::depth(float value)
{
    // perform any necessary conversion to user variables, validation, etc.
    m_depth = value;
    _depth = getUserParamValue(Depth_e, m_depth);
    if (_depth < 1) _depth = 1 ;
    if (_depth > 3) _depth = 3 ;
    set_taps () ;
    efxLogger.printf("ChorusVibrato::depth: %d\n", _depth);
}

void ChorusVibrato::mix(float value)
{
   m_mix = value;
}

void ChorusVibrato::led(float value)
{
  // status only
}


//////////////////////////////////// line unit circuit simulation //////////////////////////////////

static constexpr float dt = 1.0f / (OVERSAMPLING_RATE * AUDIO_SAMPLE_RATE_EXACT) ;
static constexpr float Rind = 200.0 ;  // perhaps 500 is less resonant?

// inductances in henries
static constexpr float ind [] =
{
  0.5, 0.5, 0.5, 0.5, 0.5,
  0.5, 0.5, 0.5, 0.5, 0.5,
  0.5, 0.5, 0.5, 0.5, 0.5,
  0.5, 0.5, 0.5
};

static constexpr float indInvert [] =
{
  1.0/0.5, 1.0/0.5, 1.0/0.5, 1.0/0.5, 1.0/0.5,
  1.0/0.5, 1.0/0.5, 1.0/0.5, 1.0/0.5, 1.0/0.5,
  1.0/0.5, 1.0/0.5, 1.0/0.5, 1.0/0.5, 1.0/0.5,
  1.0/0.5, 1.0/0.5, 1.0/0.5
};

#define nF4 (4.0e-9)
#define nF1 (1.0e-9)

// capacitances in farads
static constexpr float cap[] =
{
  0.0, nF4, nF4, nF4, nF4,
  nF4, nF4, nF4, nF4, nF4,
  nF4, nF4, nF4, nF4, nF4,
  nF4, nF4, nF4, nF1
};

static constexpr float capInvert[] =
{
  0.0, 1.0/nF4, 1.0/nF4, 1.0/nF4, 1.0/nF4,
  1.0/nF4, 1.0/nF4, 1.0/nF4, 1.0/nF4, 1.0/nF4,
  1.0/nF4, 1.0/nF4, 1.0/nF4, 1.0/nF4, 1.0/nF4,
  1.0/nF4, 1.0/nF4, 1.0/nF4, 1.0/nF1
};

// conductances of the resistor dividers
static constexpr float cond[] =
{
  1/(27e3+68e3),
  1/(56e3+150e3),
  1/(39e3+150e3),
  1/(33e3+180e3),
  1/(18e3+180e3),
  1/(12e3+180e3),
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 1/15e3
};

// gain factors due to resistive dividers
static constexpr float gain[] =
{
  0.716, 0.728, 0.794, 0.845, 0.909, 0.937, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1
};

// crude differential equation simulation
void ChorusVibrato::simulate_lineunit (float val)
{
  // first stage
  V[0] = val ;
  I[0] += (V[0] - V[1]) * dt / ind[0] ;
  float Iout = (V[0] - Vg) * cond[0] ;
  out[0] = V[0] * gain[0] ;

  for (int node = 1 ; node < 18 ; node++)
  {
    // middle stages
    float vdiff = V[node] - V[node+1] ;
    float vrind = I[node] * Rind ;
    vdiff -= vrind ;
    //I[node] += vdiff * dt / ind[node] ;  // (original)
    I[node] += vdiff * dt * indInvert[node] ;  // optimization by Blackaddr Audio
    float Io = I[node-1] - I[node] ;
    float iR = (V[node] - Vg) * cond[node] ;
    float iC = Io - iR ;
    V[node] += deltaVg ;
    //V[node] += iC * dt / cap[node] ;  // need to compensate for delta Vg (original)
    V[node] += iC * dt * capInvert[node] ;  // need to compensate for delta Vg (optimimization by Blackaddr Audio)
    out[node] = V[node] * gain[node] ;
    Iout += Io ;
  }
  // final stage
  float Io = I[17] ;
  float iR = V[18] * cond[18] ;
  float iC = Io - iR ;
  V[18] += iC * dt / cap[18] ;
  out[18] = V[18] * gain[18] ;
  Iout += Io ;
  if (!vibrato)  // for chorus the "ground" side of LC network is floated through a resistor
  {
    deltaVg = Iout * 22e3 - Vg ;
    Vg = Iout * 22e3 ;
  }
  else
  {
    deltaVg = 0 ;
    Vg = 0 ;
  }
}


//////////////////////////////////// tap point setup //////////////////////////////////


static constexpr byte tap_points_1[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 7, 6, 5, 4, 3, 2, 1, 0 };
static constexpr byte tap_points_2[] = { 0, 1, 2, 4, 6, 8,10,11,12,11,10, 8, 6, 4, 2, 1, 0 };
static constexpr byte tap_points_3[] = { 0, 1, 3, 6, 9,12,15,17,18,17,15,12, 9, 6, 3, 1, 0 };

void ChorusVibrato::set_taps ()
{
  switch (_depth)
  {
  case 1:
    tap = tap_points_1 [scanner_seg] ;
    ntap = tap_points_1 [scanner_seg+1] ;
    break ;
  case 2:
    tap = tap_points_2 [scanner_seg] ;
    ntap = tap_points_2 [scanner_seg+1] ;
    break ;
  case 3:
    tap = tap_points_3 [scanner_seg] ;
    ntap = tap_points_3 [scanner_seg+1] ;
    break ;
  }
}

//////////////////////////////////// oversampling interpolation filter //////////////////////////////////

#define a0 0.0572
#define a1 -1.21888
#define a2  0.44768

// interpolation filter for up-sampling before circuit sim.
float ChorusVibrato::butterworth (float t)
{
  t -= a1 * filtvals[0] ;
  t -= a2 * filtvals[1] ;
  float u = t ;
  t += 2 * filtvals[0] ;
  t += filtvals[1] ;
  filtvals[1] = filtvals[0] ;
  filtvals[0] = u ;

  return a0 * t ;
}

}
